---
sidebar_position: 9
tags:
- mysql
- mysql 索引
---

# Mysql 索引
## 1.1 概念：
索引的定义就是帮助存储引擎[快速获取数据]的一种[数据结构]，形象的说就是索引是数据的目录。 
是帮助MYSQL高效获取数据的数据结构（有序）。
MYSQL维护满足特定查找算法的数据结构，它们以某种方式指向数据，
可以根据此数据结构实现高级查找算法

作用：
提高数据库性能最常用的工具

## 1.2 存储位置：
一般索引本身也很大，不能全部存储在内存，以[索引文件的形式存在磁盘]上

## 1.3 索引的基本原理
索引就是把无序的数据变成有序的查询
1. 把创建了索引的列的内容进行排序
2. 对排序结果生成倒排表
3. 在倒排表内容上拼上数据地址链
4. 在查询的时候，先拿到倒排表内容，再取出数据地址链从而拿到具体数据

## 1.4 索引算法
1. BTree算法
   - 因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量
2. HASH算法
   - HASH索引只能能[用于对等比较]，不能用于范围次定位数据，效率高

## 1.5 前缀索引
- 语法：
  - index(field(10))，使用字段值的前10个字符建立索引， 
  - 默认是使用字段的全部内容建立索引。

- 前提：
  - [前缀的标识度高]。比如[密码]就适合建立前缀索引，因为密码几乎各不相同。
  - 实操的难度：在于前缀截取的长度。

我们可以利用select count(*)/count(distinct left(password,prefixLen)); 
通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了
（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）

# 2 索引优缺点
- 优点：
  1. 类似于目录，提高数据检索的效率，降低数据库IO成本
  2. 通过索引对数据排序，降低数据排序的成本，降低CPU消耗
- 缺点：
  1. 索引实际也是一张表，保存主键和索引字段并指向实体记录，[占空间]
  2. [降低了更新标的速度]，INSERT UPDATE DELETE的操作会变慢， 因为不仅保存数据信息，还有保存索引信息
  3. 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率
  
    
# 3 索引的分类

你知道索引有哪些吗？大家肯定都能霹雳啪啦地说出聚簇索引、主键索引、二级索引、普通索引、唯一索引、hash索引、B+树索引等等。

然后再问你，你能将这些索引分一下类吗？可能大家就有点模糊了。其实，要对这些索引进行分类，要清楚这些索引的使用和实现方式，然后再针对有相同特点的索引归为一类。

我们可以按照四个角度来分类索引。

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

接下来，按照这些角度来说说各类索引的特点。
1. BTREE索引
2. HASH索引：memory引擎支持，使用场景简单
   1. 为什么 MySQL 没有使用其作为索引的数据结构呢？ 主要是因为 Hash 索引不支持顺序和范围查询
3. R-TREE索引：空间索引，用于地理空间数据类型
4. fulltext索引：全文索引，用于全文搜索

MySQL 8.x 中实现的索引新特性：
- 隐藏索引：
  - 也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。
- 降序索引：
  - 之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。
  - 另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。
- 函数索引：
  - 从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式


## 总结

这次主要介绍了索引的原理、分类和使用。我把重点总结在了下面这个表格
![img.png](images/9.索引相关/总结.png)

## 3.1 按数据结构分类

从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。

每一种存储引擎支持的索引类型不一定相同，我在表中总结了MySQL常见的存储引擎InnoDB、MyISAM 和 Memory分别支持的索引类型。

![img.png](images/9.索引相关/索引分类.png)

InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：

- 如果有主键，[默认会使用主键]作为聚簇索引的索引键（key）；
- 如果没有主键，就选择[第一个不包含 NULL 值的唯一列]作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB [将自动生成一个隐式自增 id] 列作为聚簇索引的索引键（key）；

其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。**创建的主键索引和二级索引默认使用的是 B+Tree 索引**。

为了让大家理解 B+Tree 索引的存储和查询的过程，接下来我通过一个简单例子，说明一下 B+Tree 索引在存储数据中的具体实现。

先创建一张商品表，id 为主键，如下：

```sql
CREATE TABLE `product`  (
  `id` int(11) NOT NULL,
  `product_no` varchar(20)  DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `price` decimal(10, 2) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
```

商品表里，有这些行数据：

![img.png](images/9.索引相关/商品表.png)

这些行数据，存储在 B+Tree 索引时是长什么样子的？

B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是**按主键顺序存放**的。
每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，
并且每一个叶子节点都指向下一个叶子节点，形成一个链表。

主键索引的 B+Tree 如图所示：

![img.png](主键索引 B+Tree.png)

### 3.1.1 通过主键查询商品数据的过程

比如，我们执行了下面这条查询语句，这条语句使用了主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：

- 将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；
- 在第二层的索引数据  (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；
- 在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。

数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，
也就是进行了 3 次 I/O 操作。

B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，
所以**B+Tree 相比于 B 树和二叉树来说，最大的优势在于[查询效率很高]，因为即使在数据量很大的情况，
查询一个数据的磁盘 I/O 依然维持在 3-4次。**

### 3.1.2 通过二级索引查询商品数据的过程

主键索引的 B+Tree  和二级索引的 B+Tree 区别如下：

- 主键索引的 B+Tree  的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree  的叶子节点存放的是主键值，而不是实际数据。

我这里将前面的商品表中的 product_no （商品编码）字段设置为二级索引，那么二级索引的 B+Tree 如下图，
其中非叶子的 key 值是 product_no（图中橙色部分），叶子节点存储的数据是主键值（图中绿色部分）。

![img.png](images/9.索引相关/二级索引b+tree.png)

如果我用 product_no 二级索引查询商品，如下查询语句：

```sql
select * from product where product_no = '0002';
```

会先检二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。**这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据**。如下图：

![img_1.png](images/9.索引相关/回表.png)

不过，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，比如下面这条查询语句：

```sql
select id from product where product_no = '0002';
```

**这种在二级索引的 B+Tree 就能查询到结果的过程就叫作[「覆盖索引」]，也就是只需要查一个 B+Tree 就能找到数据**。

### 3.1.3 为什么 MySQL InnoDB  选择 B+tree 作为索引的数据结构？

前面已经讲了 B+Tree 的索引原理，现在就来回答一下 B+Tree 相比于 B 树、二叉树或 Hash 索引结构的优势在哪儿？

之前我也专门写过一篇文章，想详细了解的可以看这篇：「[女朋友问我：为什么 MySQL 喜欢 B+ 树？我笑着画了 20 张图](https://mp.weixin.qq.com/s/w1ZFOug8-Sa7ThtMnlaUtQ)」，这里就简单做个比对。

***1、B+Tree vs B Tree***

B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，
[在相同的磁盘 I/O 次数下，就能查询更多的节点]。

另外，B+Tree [叶子节点采用的是双链表连接]，适合 MySQL 中常见的[基于范围的顺序查找]，而 B 树无法做到这一点。

***2、B+Tree vs 二叉树***

对于有 N 个叶子节点的 B+Tree，其搜索复杂度为`O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。

在实际的应用当中， d 值是大于100的，这样就保证了，[即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右]，
也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。

而二叉树的每个父节点的儿子节点个数只能是 2 个，[意味着其搜索复杂度为 `O(logN)]`，
这已经比 B+Tree 高出不少，因此[二叉树检索到目标数据所经历的磁盘 I/O 次数要更多]。

***3、B+Tree vs Hash***

Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。

但是 Hash 表[不适合做范围查询]，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。

## 3.2 按物理存储分类

从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。

这两个区别在前面也提到了：

- 主键索引的 B+Tree  的[叶子节点存放的是实际数据]，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree  的[叶子节点存放的是主键值]，而不是实际数据。

在查询时使用了二级索引，
- 如果[查询的数据能在二级索引里查询的到]，那么就不需要回表，这个过程就是[覆盖索引]。
- 如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，
然后再检索主键索引，就能查询到数据了，这个过程就是[回表]。

## 3.3 按字段特性分类

从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。

### 3.3.1 主键索引

主键索引就是建立在[主键字段]上的索引，通常在创建表的时候一起创建，一张表[最多只有一个主键索引]，
索引列的值[不允许有空值]。

在创建表时，创建主键索引的方式如下：

```sql
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```

### 3.3.2 唯一索引

唯一索引建立在 UNIQUE 字段上的索引，一张表[可以有多个唯一索引]，索引[列的值必须唯一]，但是[允许有空值]。

在创建表时，创建唯一索引的方式如下：

```sql
CREATE TABLE table_name  (
  ....
  UNIQUE KEY(index_column_1,index_column_2,...) 
);
```

建表后，如果要创建唯一索引，可以使用这面这条命令：

```sql
CREATE UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

### 3.3.3 普通索引

普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

在创建表时，创建普通索引的方式如下：

```sql
CREATE TABLE table_name  (
  ....
  INDEX(index_column_1,index_column_2,...) 
);
```

建表后，如果要创建普通索引，可以使用这面这条命令：

```sql
CREATE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

### 3.3.4 前缀索引

前缀索引是指[对字符类型字段的前几个字符建立的索引]，而不是在整个字段上建立的索引，
前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。

使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。

在创建表时，创建前缀索引的方式如下：

```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 
```

建表后，如果要创建前缀索引，可以使用这面这条命令：

```sql
CREATE INDEX index_name
ON table_name(column_name(length)); 
```

## 3.4 按字段个数分类

从字段个数的角度来看，索引分为[单列索引]、[联合索引（复合索引）]。

- 建立在单列上的索引称为单列索引，比如主键索引；
- 建立在多列上的索引称为联合索引；

### 3.4.1  联合索引

通过将多个字段组合成一个索引，该索引就被称为联合索引。

比如，将商品表中的 product_no 和 name 字段组合成联合索引` (product_no, name)`，创建联合索引的方式如下：

```sql
CREATE INDEX index_product_no_name ON product(product_no, name);
```

联合索引` (product_no, name)` 的 B+Tree 示意图如下：

![img.png](images/9.索引相关/联合索引.png)

可以看到，联合索引的非叶子节点用两个字段的值作为  B+Tree 的 key 值。当在联合索引查询数据时，
先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。

也就是说，联合索引查询的 B+Tree 是[先按 product_no 进行排序]，然后[再 product_no 相同的情况再按 name 字段排序]。

因此，使用联合索引时，存在**最左匹配原则**，也就是按照[最左优先]的方式进行索引的匹配。在使用联合索引进行查询的时候，
如果[不遵循「最左匹配原则」，联合索引会失效]，这样就无法利用到索引快速查询的特性了。

比如，如果创建了一个 `(a, b, c)` 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：

- where a=1；
- where a=1 and b=2 and c=3；
- where a=1 and b=2；

需要注意的是，因为[有查询优化器]，所以 [a 字段在 where 子句的顺序并不重要]。

但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:

- where b=2；
- where c=3；
- where b=2 and c=3；

上面这些查询条件之所以会失效，是因为`(a, b, c)` 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，
在 b 相同的情况再按 c 排序。所以，**[b 和 c 是全局无序，局部相对有序的]**，
这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。

我这里举联合索引（a，b）的例子，该联合索引的 B+ Tree 如下：

![img.png](images/9.索引相关/联合索引ab.png)

可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。
因此，直接执行`where b = 2`这种查询条件没有办法利用联合索引的，**[利用索引的前提是索引里的 key 是有序的]**。

只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，
这个有序状态是局部的，因此，执行`where a = 2 and b = 7`是[a 和 b 字段能用到联合索引]的， 也就是联合索引生效了。

#### 3.4.1.1 联合索引范围查询

联合索引有一些特殊情况，**并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询**，
也就是[可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况]。

这种特殊情况就发生在[范围查询]。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。
**也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引**。

范围查询有很多种，那到底是哪些范围查询会导致联合索引的最左匹配原则会停止匹配呢？

接下来，举例几个范围查例子。

> Q1: `select * from t_table where a > 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a > 1 条件的二级索引记录肯定是相邻，
于是在进行索引扫描的时候，可以定位到符合 a > 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，
直到某条记录不符合 a > 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。

**但是在符合 a > 1  条件的二级索引记录的范围里，b 字段的值是无序的**。
比如前面图的联合索引的 B+ Tree 里，下面这三条记录的 a 字段的值都符合 a > 1  查询条件，
而 b 字段的值是无序的：

- a 字段值为 5 的记录，该记录的 b 字段值为 8；
- a 字段值为 6 的记录，该记录的 b 字段值为 10；
- a 字段值为 7 的记录，该记录的 b 字段值为 5；

因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量（b 字段无法利用联合索引进行索引查询的意思）。

所以在执行 Q1 这条查询语句的时候，对应的扫描区间是 (2, + ∞)，形成该扫描区间的边界条件是 a > 1，与 b = 2 无关。

因此，**Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引**。

我们也可以在执行计划中的 key_len 知道这一点，在使用联合索引进行查询的时候，
通过 key_len 我们可以知道[优化器具体使用了多少个字段的搜索条件]来形成扫描区间的边界条件。

举例个例子 ，a 和 b 都是 int 类型且不为 NULL 的字段，那么 Q1 这条查询语句执行计划如下，
可以看到 key_len 为 4 字节（如果字段允许为 NULL，就在字段类型占用的字节数上加 1，也就是 5 字节），
说明只有 a 字段用到了联合索引进行索引查询，而且可以看到，即使 b 字段没用到联合索引，key 为 idx_a_b，
说明  Q1 查询语句使用了 idx_a_b 联合索引。

![img.png](images/9.索引相关/联合索引失效1.png)

通过 Q1 查询语句我们可以知道，a 字段使用了 > 进行范围查询，联合索引的最左匹配原则在遇到 a 字段的范围查询（ >）后就停止匹配了，
因此 b 字段并没有使用到联合索引。

> Q2: `select * from t_table where a >= 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

Q2 和 Q1 的查询语句很像，唯一的区别就是 a 字段的查询条件「大于等于」。

由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 >= 1 条件的二级索引记录肯定是相邻，
于是在进行索引扫描的时候，可以定位到符合 >= 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，
直到某条记录不符合 a>= 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。

虽然在符合 a>= 1  条件的二级索引记录的范围里，b 字段的值是「无序」的，
**但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的**
（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。

于是，在[确定需要扫描的二级索引的范围]时，当二级索引记录的 a 字段值为 1 时，
可以通过 b = 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。
也就是说，从符合 a = 1 and b = 2 条件的第一条记录开始扫描，而[不需要从第一个 a 字段值为 1 的记录]开始扫描。

所以，**Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询**。

我们也可以在执行计划中的 key_len 知道这一点。执行计划如下，可以看到 key_len 为 8 字节，
说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是  a 和 b 字段都用到了联合索引进行索引查询。

![img.png](images/9.索引相关/联合索引2.png)

通过 Q2 查询语句我们可以知道，虽然 a 字段使用了 >= 进行范围查询，但是联合索引的最左匹配原则并没有在遇到
a 字段的范围查询（ >=）后就停止匹配了，b 字段还是可以用到了联合索引的。

> Q3: ` SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

Q3 查询条件中 `a BETWEEN 2 AND 8` 的意思是查询 a 字段的值在 2 和 8 之间的记录。
不同的数据库对 BETWEEN ... AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，
类似于 \>= and =<。而有的数据库则不包含 value1 和 value2 边界值（类似于 > and <）。

这里我们只讨论 MySQL。由于[ MySQL 的 BETWEEN 包含 value1 和 value2 边界值]，所以类似于 Q2 查询语句，
因此 **Q3 这条查询语句 a 和 b 字段都[用到了联合索引进行索引查询]**。

我们也可以在执行计划中的 key_len 知道这一点。执行计划如下，可以看到 key_len 为 8 字节，
说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是  a 和 b 字段都用到了联合索引进行索引查询。

![img.png](images/9.索引相关/联合索引3.png)

通过 Q3 查询语句我们可以知道，虽然 a 字段使用了 BETWEEN 进行范围查询，
但是联合索引的最左匹配原则并没有在遇到 a 字段的范围查询（ BETWEEN）后就停止匹配了，
b 字段还是可以用到了联合索引的。

> Q4: ` SELECT * FROM t_user WHERE name like 'j%' and age = 22`，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？

由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的， 
于是在进行索引扫描的时候，可以定位到符合前缀为 ‘j’ 的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，
直到[某条记录的 name 前缀不为 ‘j’  ]为止。

所以 a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是['j','k')。注意， 
j 是闭区间。如下图：

![img.png](images/9.索引相关/联合索引like1.png)

虽然在符合前缀为 ‘j’ 的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，
**但是对于[符合 name = j 的二级索引记录的范围里，age字段的值是「有序」]的**
（因为对于联合索引，是先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，
再按照 age 字段的值进行排序）。

于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 name 字段值为 ‘j’ 时，
可以通过 age = 22 条件减少需要扫描的二级索引记录范围（age 字段可以利用联合索引进行索引查询的意思）。
也就是说，从符合 [`name = 'j' and age = 22`] 条件的第一条记录时开始扫描，
而不需要从第一个 name 为 j 的记录开始扫描 。如下图的右边：

![img.png](images/9.索引相关/联合索引like2.png)

所以，**Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询**。

我们也可以在执行计划中的 key_len 知道这一点。本次例子中：

- name 字段的类型是 varchar(30) 且不为 NULL，数据库表使用了 utf8mb4 字符集，一个字符集为 utf8mb4 的字符是 4 个字节，因此 name 字段的实际数据最多占用的存储空间长度是 120 字节（30 x 4），然后因为 name 是变长类型的字段，需要再加 2，也就是 name 的 key_len 为 122。

- age 字段的类型是 int 且不为 NULL，key_len 为 4。

Q4 查询语句的执行计划如下，可以看到 key_len 为 126 字节，name 的 key_len 为 122，age 的 key_len 为 4，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是  name 和 age 字段都用到了联合索引进行索引查询。

![img.png](images/9.索引相关/联合索引like3.png)

通过 Q4 查询语句我们可以知道，虽然 name 字段使用了 like 前缀匹配进行范围查询，但是联合索引的最左匹配原则
并没有在遇到 name 字段的范围查询（ like 'j%'）后就停止匹配了，age 字段还是可以用到了[联合索引]的。

综上所示，**联合索引的最左匹配原则，在遇到范围查询（如 \>、<）的时候，就会停止匹配，
也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。
注意，对于 [>=、<=、BETWEEN、like] 前缀匹配的范围查询，[并不会停止匹配]，前面我也用了四个例子说明了**。

#### 3.4.1.2 索引下推

现在我们知道，对于联合索引（a, b），在执行 `select * from table where a > 1 and b = 2` 语句的时候，
只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，
还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？

- 在 MySQL 5.6 之前，只能从 [ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值]。

- 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， 
**可以在联合索引遍历过程中，对[联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数]**。

当你的查询语句的执行计划里，出现了  Extra 为 `Using index condition`，那么说明使用了索引下推的优化。

#### 3.4.1.3 索引区分度

另外，建立联合索引时的字段顺序，对索引效率也有很大影响。[越靠前的字段被用于索引过滤的概率越高]，
实际开发工作中**建立联合索引时，要[把区分度大的字段排在前面]，这样区分度大的字段越有可能被更多的 SQL 使用到**。

区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：

![img.png](images/9.索引相关/区分度计算公式.png)

比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，
而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。

因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。
在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，[查询优化器发现某个值出现在表的数据行中的百分比（
惯用的百分比界线是"30%"）很高的时候，它一般会忽略索引，进行全表扫描]。

#### 3.4.1.4 联合索引进行排序

这里出一个题目，针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？

```sql
select * from order where status = 1 order by create_time asc
```

有的同学会认为，单独给 status 建立一个索引就可以了。

但是更好的方式[给 status 和 create_time 列建立一个联合索引]，因为这样可以避免 MySQL 数据库发生文件排序。

因为在查询时，如果只用到 status 的索引，[但是这条语句还要对 create_time 排序]，
这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 [Using filesort]。

所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，
这样[根据 status 筛选后的数据就是按照 create_time 排好序]的，[避免在文件排序，提高了查询效率]。

## 3.5 什么时候需要 / 不需要创建索引？

索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：

- 需要[占用物理空间]，数量越大，占用空间越大；
- [创建索引和维护索引要耗费时间]，这种时间随着数据量的增加而增大；
- [会降低表的增删改的效率]，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。

所以，索引不是万能钥匙，它也是根据场景来使用的。

### 3.5.1 什么时候适用索引？

- 字段有[唯一性限制的]，比如商品编码；
- 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，
  因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

### 3.5.2 什么时候不需要创建索引？

- `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段，索引的价值是快速定位，
    如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- [字段中存在大量重复数据]，不需要创建索引，比如性别字段，只有男女，如果数据库表中，
  男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，
  因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，
  它[一般会忽略索引，进行全表扫描]
- 表数据太少的时候，不需要创建索引；
- [经常更新]的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，
   由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

## 3.6 有什么优化索引的方法？

这里说一下几种常见优化索引的方法：

- 前缀索引优化；
- 覆盖索引优化；
- 主键索引最好是自增的；
- 防止索引失效；

### 3.6.1 前缀索引优化

前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？

使用[前缀索引是为了减小索引字段大小]，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。
[在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小]。

不过，前缀索引有一定的局限性(缺点），例如：

- order by 就无法使用前缀索引；
- 无法把前缀索引用作覆盖索引；

## 3.6.2 覆盖索引优化

覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree  的叶子节点上都能找得到的那些索引，
从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。

假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？

我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，
[查询将不会再次检索主键索引]，从而避免回表。

所以，使用覆盖索引的好处就是，[不需要查询出包含整行记录的所有信息]，也就减少了大量的 I/O 操作。

### 3.6.3 主键索引最好是自增的

我们在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？

InnoDB 创建主键索引默认为[聚簇索引[，数据被存放在了 B+Tree 的叶子节点上。也就是说，
同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，
数据库会根据主键将其插入到对应的叶子节点中。

**如果我们使用自增主键**，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，
当页面写满，就会自动开辟一个新页面。因为每次**插入一条新记录，都是追加操作，不需要重新移动数据**，
因此这种[插入数据的方法效率非常高]。

**如果我们使用非自增主键**，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，
就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，
甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为**页分裂**。
**页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率**。

举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，
则需要把数据页分割为两个数据页：

![img.png](images/9.索引相关/页分裂1.png)

出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。

而如果记录是顺序插入的，例如插入数据11，则只需开辟新的数据页，也就不会发生页分裂：

![img.png](images/9.索引相关/开辟新页.png)

因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。

另外，主键字段的长度不要太大，因为**主键字段长度越小，[意味着二级索引的叶子节点越小]
（二级索引的叶子节点存放的数据是主键值），这样[二级索引占用的空间也就越小]**。

### 3.6.4 索引最好设置为 NOT NULL

为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：

- 第一原因：索引列存在 NULL 就会[导致优化器在做索引选择的时候更加复杂]，更加难以优化，
   因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。

- 第二个原因：NULL 值是一个没意义的值，但是[它会占用物理空间]，所以会带来的存储空间的问题，
   会导致更多的存储空间占用，因为 InnoDB 默认行存储格式`COMPACT`，会用 1 字节空间存储 NULL 值列表，
    如下图的黄色部分：

![img.png](images/9.索引相关/行数据存储.png)

### 3.6.5 防止索引失效

用上了索引并不意味着查询的时候会使用到索引，所以我们心里要清楚有哪些情况会导致索引失效，
从而避免写出索引失效的查询语句，否则这样的查询效率是很低的。

我之前写过索引失效的文章，想详细了解的可以去看这篇文章：[谁还没碰过索引失效呢?](https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w)

这里简单说一下，发生索引失效的情况：

- 当我们使用[左或者左右模糊匹配]的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当我们在查询条件中[对索引列做了计算、函数、类型转换]操作，这些情况下都会造成索引失效；
- 联合索引要能正确使用需要遵循[最左匹配原则]，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 [OR 前的条件列是索引列，而在 OR 后的条件列不是索引列]，那么索引会失效。

我上面说的是常见的索引失效场景，实际过程中，可能会出现其他的索引失效场景，这时我们就需要查看执行计划，通
过执行计划显示的数据[判断查询语句是否使用了索引]。

如下图，就是一个没有使用索引，并且是一个全表扫描的查询语句。

![img.png](images/9.索引相关/索引失效explain1111.png)

对于执行计划，参数有：

- possible_keys 字段表示可能用到的索引；
- key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；
- key_len 表示索引的长度；
- rows 表示扫描的数据行数。
- type 表示数据扫描类型，我们需要重点看这个。

type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的**执行效率从低到高的顺序为**：

- All（全表扫描）；
- index（全索引扫描）；
- range（索引范围扫描）；
- ref（非唯一索引扫描）；
- eq_ref（唯一索引扫描）；
- const（结果只有一条的主键或唯一索引扫描）。

在这些情况里，all 是最坏的情况，因为采用了全表扫描的方式。index 和 all 差不多，只不过 index 对索引表进行全扫描，
这样做的好处是[不再需要对数据进行排序]，但是开销依然很大。所以，要尽量避免全表扫描和全索引扫描。

range 表示采用了索引范围扫描，一般在 where 子句中使用 < 、>、in、between 等关键词，只检索给定范围的行，
属于[范围查找]。**从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 
range 这一级别及以上的 type 访问方式**。

ref 类型表示采用了[非唯一索引]，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，
但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围
扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。

eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，
关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，
type 就会显示 eq_ref。

const 类型表示使用了[主键或者唯一索引与常量值]进行比较，比如 select name  from product where id=1。

需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，
**const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中**。

> 除了关注 type，我们也要关注 extra 显示的结果。

这里说几个重要的参考指标：

- Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这
  时不得不选择相应的排序算法进行，甚至可能会通过文件排序，[效率是很低的，所以要避免这种问题的出现]。
- Using temporary：[使了用临时表保存中间结果]，MySQL 在对查询结果排序时使用临时表，
   常见于排序 order by 和分组查询 group by。[效率低，要避免这种问题的出现]。
- Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是[使用了覆盖索引,避免了回表操作，效率不错]。


# 4. 从数据页的角度看 B+ 树
这次，我们**从数据页的角度看 B+ 树**，看看每个节点长啥样。

![img.png](images/9.索引相关/从数据页角度看B+树.png)

## 4.1 InnoDB 是如何存储数据的？

MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同的，我们最常使用的是 InnoDB 存储引擎，所以就跟大家图解下InnoDB 是如何存储数据的。

记录是[按照行来存储]的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。

因此，**InnoDB 的数据是按「数据页」为单位来读写的**，也就是说，当需要读一条记录的时候，
并不是将这个记录本身从磁盘读出来，而是[以页为单位，将其整体读入内存]。

数据库的 I/O 操作的最小单位是页，**InnoDB 数据页的默认大小是 16KB**，意味着数据库每次读写都是
以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次[最少把内存中的 16K ]内容刷新到磁盘中。

数据页包括七个部分，结构如下图：

![img.png](images/9.索引相关/数据页内容.png)

这 7 个部分的作用如下图：

![img.png](images/9.索引相关/数据页内容的作用.png)

在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：

![img.png](images/9.索引相关/数据页链表.png)

采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。

数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。

**数据页中的记录按照「主键」顺序组成单向链表**，单向链表的特点就是插入、删除非常方便，但是检索效率不高，
[最差的情况下需要遍历链表上的所有节点才能完成检索]。

因此，数据页中有一个**页目录**，起到[记录的索引作用]，就像我们书那样，针对书中内容的每个章节设立了一个目录，
想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。

那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：

![img.png](images/9.索引相关/数据页目录.png)

页目录创建的过程如下：

1. 将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；
2. 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，
    作为 n_owned 字段（上图中粉红色字段）
3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，
   每组的地址偏移量也被称之为槽（slot），**每个槽相当于指针指向了不同组的最后一个记录**。

从图可以看到，**页目录就是由多个槽组成的，槽相当于分组记录的索引**。然后，因为记录是按照「主键值」
从小到大排序的，所以**我们通过槽查找记录时，可以[使用二分法快速定位]要查询的记录在哪个槽（哪个记录分组），
定位到槽后，[再遍历槽内的所有记录]，找到对应的记录**，无需从最小记录开始遍历整个页中的记录链表。

以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：

- 先二分得出槽中间位是 (0+4)/2=2 ，2号槽里最大的记录为 8。因为 11 > 8，所以需要从 2 号槽后继续搜索记录；
- 再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)/2= 3，3 号槽里最大的记录为 12。因为 11 < 12，
  所以主键为 11 的记录在 3 号槽里；
- 这里有个问题，**「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」**？
  比如槽 3 对应最大主键是 12 的记录，那如何找到最小记录 9。解决办法是：通过槽 3 找到 槽 2 对应的记录，
  也就是主键为 8 的记录。主键为 8 的记录的下一条记录就是槽 3 当中主键最小的 9 记录，然后开始向下搜索 2 次
  定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。

看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？

这点不用担心，InnoDB 对[每个分组中的记录条数都是有规定的]，槽内的记录就只有几条：

- 第一个分组中的记录只能有 1 条记录；
- 最后一个分组中的记录条数范围只能在 1-8 条之间；
- 剩下的分组中记录条数范围只能在 4-8 条之间。

## 4.2 B+ 树是如何进行查询的？

上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，
所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，
通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。

但是，当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。

为了解决这个问题，**InnoDB 采用了 B+ 树作为索引**。磁盘的 I/O 操作次数对索引的使用效率至关重要，
因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，
而且 B+ 树 更适合进行关键字的范围查询。

InnoDB 里的 B+ 树中的**每个节点都是一个数据页**，结构示意图如下：

![img.png](images/9.索引相关/B+树%20数据页.png)

通过上图，我们看出  B+ 树的特点：

- 只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。
- 非叶子节点分为不同层次，通过分层来降低每一层的搜索量；
- 所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；

我们再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：

- 从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，
  所以到页 30 中查找更详细的目录项；
- 在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，
  所以就到叶子节点（页16）查找记录；
- 接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），
  定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。

可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。

## 4.3 聚簇索引和二级索引

另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：

- 聚簇索引的叶子节点存放的是实际数据，[所有完整的用户记录都存放在聚簇索引的叶子节点]；
- 二级索引的叶子节点存放的是主键值，而不是实际数据。

因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，
且[由于数据在物理上只会保存一份，所以聚簇索引只能有一个]。

InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；

一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），
它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。

二级索引的 B+ 树如下图，数据部分为主键值：

![img.png](images/9.索引相关/二级索引.png)


因此，**如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，
这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，
这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。**

## 4.4 总结

InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，
物理上不连续，但是逻辑上连续。

数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，
页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。

为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。

如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，
而是主键值则就是二级索引，一个表中可以有多个二级索引。

在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，
如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，
这个过程就叫作「回表」。


# 5 为什么 MySQL 采用 B+ 树作为索引？



要解释这个问题，其实不单单要从数据结构的角度出发， 还要考虑磁盘 I/O 操作次数，
因为 MySQL 的数据是存储在磁盘中的嘛。

这次，就跟大家一层一层的分析这个问题，图中包含大量的动图来帮助大家理解，相信看完你就拿捏这道题目了！

![img.png](images/9.索引相关/总结5.png)

## 5.1 怎样的索引的数据结构是好的？

MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失。

磁盘是一个慢的离谱的存储设备，有多离谱呢？

人家内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的，也就是说读取同样大小的数据，
磁盘中读取的速度比从内存中读取的速度要[慢上万倍，甚至几十万倍]。

磁盘读写的最小单位是**扇区**，扇区的大小只有 `512B` 大小，操作系统一次会读写多个扇区，所以**操作系统的最小读写单位是块（Block）。
Linux 中的块大小为 `4KB`**， 也就是[一次磁盘  I/O 操作会直接读写 8 个扇区]。

由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，
再通过索引[从磁盘中找到某行数据，然后读入到内存[，也就是说查询过程中会发生多次磁盘 I/O，
而[磁盘 I/O 次数越多， 所消耗的时间也就越大]。

所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘I/O 操作越少，所消耗的时间也就越小。

另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能[高效地执行范围查找]。

所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：
- 能在[尽可能少的磁盘的 I/O 操作中完成查询]工作；
- 要能[高效地查询某一个记录]，也要能[高效地执行范围查找]；

分析完要求后，我们针对每一个数据结构分析一下。

## 5.2 什么是二分查找？

索引数据最好能按顺序排列，这样可以使用「二分查找法」高效定位数据。

假设我们现在用数组来存储索引，比如下面有一个排序的数组，如果要从中找出数字 3，最简单办法就是从头依次遍历查询，
这种方法的时间复杂度是 O(n)，查询效率并不高。因为该数组是有序的，所以我们可以采用二分查找法，
比如下面这张采用二分法的查询过程图：

![img.png](images/9.索引相关/二分查找法.png)

可以看到，二分查找法每次都把查询的范围减半，这样时间复杂度就降到了 O(logn)，但是每次查找都需要不断计算中间位置。

## 5.3 什么是二分查找树？

用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。

因为插入一个元素，需要将这个元素之后的所有元素后移一位，如果这个操作发生在磁盘中呢？这必然是灾难性的。
因为磁盘的速度比内存慢几十万倍，所以我们不能用一种线性结构将磁盘排序。

其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。

那我们能不能设计一个非线形且天然适合二分查找的数据结构呢？

有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，把他们用指针连起来，
并将最中间的节点作为根节点。

![img.png](images/9.索引相关/二分查找树.png)

怎么样？是不是变成了二叉树，不过它不是普通的二叉树，它是一个**二叉查找树**。

**二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点**，
这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。

假设，我们查找索引值为 key 的节点：

1. 如果 key 大于根节点，则在右子树中进行查找；
2. 如果 key 小于根节点，则在左子树中进行查找；
3. 如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。

二叉查找树查找某个节点的动图演示如下，比如要查找节点 3 ：

![图片](https://img-blog.csdnimg.cn/img_convert/f3089bdfe1a795a8142d4442bdb1e9a7.gif)

另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，
新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。

下面是二叉查找树插入某个节点的动图演示：

![请添加图片描述](https://img-blog.csdnimg.cn/be13777664584209826f90d5d4128b7f.gif)


因此，[二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构]。

那是不是二叉查找树就可以作为索引的数据结构了呢？

不行不行，二叉查找树存在一个极端情况，会导致它变成一个瘸子！

**当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)**，
如下动图演示：

![请添加图片描述](https://img-blog.csdnimg.cn/320c5c2653e74f9e9ebfcd8ca9681905.gif)

由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（*假设一个节点的大小「小于」
操作系统的最小读写单位块的大小*），也就是说**树的高度就等于每次查询数据时磁盘 IO 操作的次数**，
所以树的高度越高，就会影响查询性能。

二叉查找树由于存在退化成链表的可能性，会使得查询操作的时间复杂度从 O(logn) 升为 O(n)。

而且会随着插入的元素越多，树的高度也变高，意味着需要[磁盘 IO 操作的次数就越多，这样导致查询性能严重下降]，
再加上不能范围查询，所以不适合作为数据库的索引结构。

## 5.4 什么是自平衡二叉树？

为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出**平衡二叉查找树（AVL 树）**。

主要是在二叉查找树的基础上增加了一些条件约束：**每个节点的左子树和右子树的高度差不能超过 1**。
也就是说节点的[左子树和右子树仍然为平衡二叉树]，这样查询操作的[时间复杂度就会一直维持在 O(logn)] 。

下图是每次插入的元素都是平衡二叉查找树中最大的元素，可以看到，它会维持自平衡：

![图片](https://img-blog.csdnimg.cn/img_convert/8d5da86f2e41a0b641dbf45b23f7b7dd.gif)

除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，
不过红黑树的约束条件比较复杂，不是本篇的重点重点，大家可以看《数据结构》相关的书籍来了解红黑树的约束条件。

下面是红黑树插入节点的过程，这左旋右旋的操作，就是为了自平衡。

![图片](https://img-blog.csdnimg.cn/img_convert/b2628d1248e41207a08871f7bfac3522.gif)

**不管平衡二叉查找树还是红黑树，都会[随着插入的元素增多，而导致树的高度变高]，这就意味着磁盘 I/O 操作次数多，
会影响整体数据查询的效率**。

比如，下面这个平衡二叉查找树的高度为 5，那么在访问最底部的节点时，就需要磁盘 5 次 I/O 操作。

![图片](https://img-blog.csdnimg.cn/img_convert/2d26d30c953cd47c6ab637ad0eba2f99.png)

根本原因是因为它们都是二叉树，也就是每个节点只能保存 2 个子节点 ，如果我们把二叉树改成 M 叉树（M>2）呢？

比如，当 M=3 时，在同样的节点个数情况下，三叉树比二叉树的树高要矮。

![图片](https://img-blog.csdnimg.cn/img_convert/00fb73de7014a87958f1597345e9ef2f.png)

因此，**当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度**。

## 5.5 什么是 B 树

自平衡二叉树虽然能保持查询操作的时间复杂度在O(logn)，但是因为它本质上是一个二叉树，每个节点只能有 2 个子节点，
那么当节点个数越多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。

为了解决降低树的高度的问题，后面就出来了 B 树，它不再限制一个节点就只能有 2 个子节点，
而是[允许 M 个子节点 (M>2)]，从而降低树的高度。

B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树。

假设 M = 3，那么就是一棵 3 阶的 B 树，特点就是每个节点最多有 2 个（M-1个）数据和最多有 3 个（M个）子节点，
超过这些要求的话，就会分裂节点，比如下面的的动图：

![图片](https://img-blog.csdnimg.cn/img_convert/9a96956de3be0614f7ec2344741b4dcc.gif)

我们来看看一棵 3 阶的 B 树的查询过程是怎样的？

![图片](https://img-blog.csdnimg.cn/img_convert/341cedca6863fcd0624febd835165ae2.gif)

假设我们在上图一棵 3 阶的 B 树中要查找的索引值是 9 的记录那么步骤可以分为以下几步：

1. 与根节点的索引(4，8）进行比较，9 大于 8，那么往右边的子节点走；
2. 然后该子节点的索引为（10，12），因为 9 小于 10，所以会往该节点的左边子节点走；
3. 走到索引为9的节点，然后我们找到了索引值 9 的节点。

可以看到，一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是3，所以在查询过程中会发生3次磁盘 I/O 操作。

而如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，
B 树在数据查询中比平衡二叉树效率要高。

但是 B 树的每个节点都包含数据（索引+记录），而[用户的记录数据的大小很有可能远远超过了索引数据]，
这就需要[花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」]。

而且，在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，
但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录
数据对我们是没用的，这样[不仅增多磁盘 I/O 操作次数，也占用内存资源]。

另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会[涉及多个节点的磁盘 I/O  问题]， 从而导致整体速度下降。

## 5.6 什么是 B+ 树？

B+ 树就是对 B 树做了一个升级，MySQL 中索引的数据结构就是采用了 B+ 树，B+ 树结构如下图：

![img.png](images/9.索引相关/B+树结构.png)

B+ 树与 B 树差异的点，主要是以下这几点：

- 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；
- 所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；
- 非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。
- 非叶子节点中有多少个子节点，就有多少个索引；

### B+树索引的优点？
B+树是一种经典的数据结构，由平衡树和二叉查找树结合产生，它是为磁盘或其它直接存取辅助设备而设计的一种平衡查找树，
在B+树中，所有的记录节点都是按键值大小顺序存放在同一层的叶节点中，叶节点间用指针相连，构成双向循环链表，
非叶节点（根节点、枝节点）只存放键值，不存放实际数据。

1. B+树[的层级更少]：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；
2. B+树[查询速度更稳定]：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3. B+树[天然具备排序功能]：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，
   数据紧密性很高，缓存的命中率也会比B树高。

4. B+树[全节点遍历更快]：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，
  这有利于数据库做全表扫描。


下面通过三个方面，比较下 B+ 和 B 树的性能区别。

### 5.6.1、单点查询

B 树[进行单个索引查询]时，最快可以在 O(1) 的时间代价内就查到，而[从平均时间代价来看，会比 B+ 树稍快一些]。

但是 [B 树的查询波动会比较大]，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，
而有时需要访问到叶子节点才能找到索引。

**B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，
B+树的非叶子节点可以存放更多的索引，因此 [B+ 树可以比 B 树更「矮胖」]，查询底层节点的磁盘 I/O次数会更少**。

### 5.6.2、插入和删除效率

B+树有大量的冗余节点,这样使得删除一个节点的时候,可以直接从叶子节点中删除,甚至可不动非叶子节点，[这样删除非常快]

比如下面这个动图是删除 B+ 树 0004 节点的过程，因为非叶子节点有 0004 的冗余节点，所以在删除的时候，
树形结构变化很小：

![请添加图片描述](https://img-blog.csdnimg.cn/25508b0cd9c44ef6937fdd737020a7f1.gif)
> 注意，：B+ 树对于非叶子节点的子节点和索引的个数，定义方式可能会有不同，有的是说非叶子节点的子节点的个数为M阶，
> 而索引的个数为 M-1（这个是维基百科里的定义），因此我本文关于 B+ 树的动图都是基于这个。
> 但是我在前面介绍 B+ 树与 B+ 树的差异时，说的是「非叶子节点中有多少个子节点，就有多少个索引」，
> 主要是 MySQL 用到的 B+ 树就是这个特性。

下面这个动图是删除 B 树 0008 节点的过程，可能会导致树的复杂变化：

![请添加图片描述](https://img-blog.csdnimg.cn/2be62679487640bbaac663fa96c7f35f.gif)

甚至，B+ 树在删除根节点的时候，由于存在冗余的节点，所以不会发生复杂的树的变形，比如下面这个动图是删除 
B+ 树根节点的过程：

![请添加图片描述](https://img-blog.csdnimg.cn/23730b5af987480fabff0f1d142a2b6c.gif)

B 树则不同，[B 树没有冗余节点，删除节点的时候非常复杂]，比如删除根节点中的数据，可能涉及复杂的树的变形，
比如下面这个动图是删除 B 树根节点的过程：

![图片](https://img-blog.csdnimg.cn/img_convert/7552002f9b8195ab650d431bfe66cce2.gif)

B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。
而且 [B+ 树会自动平衡，不需要像更多复杂的算法]，类似红黑树的旋转操作等。

因此，**B+ 树的插入和删除效率更高**。

### 5.6.3、范围查询

B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。

因为 **B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助**，
比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，
然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就[不需要从根节点查询了，进一步节省查询需要的时间]。

而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，
这会涉及多个节点的磁盘 I/O 操作，[范围查询效率不如 B+ 树]。

因此，[存在大量范围检索的场景，适合使用 B+树]，比如数据库。
而对于[大量的单个索引查询的场景]， 可以考虑 B 树，比如 nosql 的MongoDB。

### 5.6.4 MySQL 中的 B+ 树

MySQL 的存储方式根据存储引擎的不同而不同，我们最常用的就是 Innodb 存储引擎，它就是采用了 B+ 
树作为了索引的数据结构。

下图就是 Innodb 里的 B+ 树：

![img.png](images/9.索引相关/innodeDb%20B+树.png)

但是 Innodb 使用的  B+ 树有一些特别的点，比如：

- B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。
- B+ 树点【节点内容是数据页】，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。

Innodb 根据索引类型不同，分为聚集和二级索引。他们区别在于，聚集索引的叶子节点存放的是实际数据，
所有完整的用户记录都存放在聚集索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。

因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，
且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。

更多关于 Innodb 的 B+ 树，可以看我之前写的这篇：[从数据页的角度看 B+ 树](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247502059&idx=1&sn=ccbee22bda8c3d6a98237be769a7c89c&scene=21#wechat_redirect)。

## 总结

MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，
实际上是在讨论存储引使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。

要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/0 的操作次数。
因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最
好能在尽可能少的磁盘 I/0 的操作次数内完成。

二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，
每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。

为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 
但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。

而树的高度决定于磁盘  I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，
也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。

B 树和 B+ 都是[通过多叉树的方式，会将树的高度变矮]，所以这两个数据结构非常适合检索存于磁盘中的数据。

但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

- B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下， 相比[存储即存索引又存记录的 B 树]，
   B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
- [B+ 树有大量的冗余节点]（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，
   比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- B+ 树叶子节点之间用链表连接了起来，[有利于范围查询]，而 B 树要实现范围查询，
  因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

# 6.MySQL 单表不要超过 2000W 行，靠谱吗？

## **总结**

- MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。
- 页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。
- 在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，
   叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。
- 索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能。
> 原文链接：https://my.oschina.net/u/4090830/blog/5559454

## 6.1 **单表数量限制**
首先我们先想想数据库单表行数最大多大？

```sql
CREATE TABLE person(
    id int(10) NOT NULL AUTO_INCREMENT PRIMARY KEY comment '主键',
    person_id tinyint not null comment '用户id',
    person_name VARCHAR(200) comment '用户名称',
    gmt_create datetime comment '创建时间',
    gmt_modified datetime comment '修改时间'
) comment '人员信息表';
```

看看上面的建表 sql。id 是主键，本身就是唯一的，也就是说[主键的大小可以限制表的上限]：

- 如果主键声明 `int` 类型，也就是 32 位，那么支持  2^32-1 ~~21 亿；
- 如果主键声明 `bigint` 类型，那就是 2^62-1 （36893488147419103232），难以想象这个的多大了，
  一般还没有到这个限制之前，可能数据库已经爆满了！！

有人统计过，如果建表的时候，自增字段选择无符号的 bigint , 那么自增长最大值是 18446744073709551615，
按照一秒新增一条记录的速度，大约什么时候能用完？

![img.png](images/9.索引相关/自增ID是否能用完.png)

## 6.2 **表空间**

下面我们再来看看索引的结构，我们下面讲内容都是基于 Innodb 引擎的，大家都知道 Innodb 的索引内部用的是 B+ 树。

![img.png](images/9.索引相关/表数据.png)

这张表数据，在硬盘上存储也是类似如此的，它实际是放在一个叫 person.ibd （innodb data）的文件中，
也叫做表空间；虽然数据表中，他们看起来是一条连着一条，但是实际上在文件中它被分成很多小份的数据页，
而且每一份都是 16K。

大概就像下面这样，当然这只是我们抽象出来的，在表空间中还有段、区、组等很多概念，但是我们需要跳出来看。

![img.png](images/9.索引相关/数据存储.png)

## 6.3 **页的数据结构**

实际页的内部结构像是下面这样的：

![img.png](images/9.索引相关/页的数据结构.png)

从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。

在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到 `User Records` 部分。

但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，
也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分。

当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，
如果还有新的记录插入的话，就需要去申请新的页了。

这个过程的图示如下：

![img.png](images/9.索引相关/freeSpace.png)

刚刚上面说到了数据的新增的过程。

那下面就来说说，数据的查找过程，假如我们需要查找一条记录，我们可以把表空间中的每一页都加载到内存中，
然后对记录挨个判断是不是我们想要的。

在数据量小的时候，没啥问题，内存也可以撑。但是现实就是这么残酷，不会给你这个局面。

为了解决这问题，MySQL 中就有了索引的概念，大家都知道索引能够加快数据的查询，那到底是怎么个回事呢？
下面我就来看看。

## 6.4 **索引的数据结构**

在 MySQL 中索引的数据结构和刚刚描述的页几乎是一模一样的，而且大小也是 16K,。

但是在索引页中记录的是页 (数据页，索引页) 的最小主键 id 和页号，以及在索引页中增加了层级的信息，
从 0 开始往上算，所以页与页之间就有了上下层级的概念。

![img.png](images/9.索引相关/索引的数据结构.png)

看到这个图之后，是不是有点似曾相似的感觉，是不是像一棵二叉树啊，对，没错！它就是一棵树。

只不过我们在这里只是简单画了三个节点，2 层结构的而已，如果数据多了，可能就会扩展到 3 层的树，
这个就是我们常说的 B+ 树，最下面那一层的 page level =0, 也就是叶子节点，其余都是非叶子节点。

![img.png](images/9.索引相关/索引页.png)

看上图中，我们是单拿一个节点来看，首先它是一个非叶子节点（索引页），在它的内容区中有 id 和 页号地址两部分：

- id ：对应页中记录的最小记录 id 值；
- 页号：地址是指向对应页的指针；

而数据页与此几乎大同小异，区别在于数据页记录的是真实的行数据而不是页地址，而且 id 的也是顺序的。

## 6.5 **单表建议值**

下面我们就以 3 层，2 分叉（实际中是 M 分叉）的图例来说明一下查找一个行数据的过程。

![img.png](images/9.索引相关/三层两分叉.png)

比如说我们需要查找一个 id=6 的行数据：

- 因为在非叶子节点中存放的是页号和该页最小的 id，所以我们从顶层开始对比， 首先看页号 10 中的目录,
  有 [id=1, 页号 = 20],[id=5, 页号 = 30], 说明左侧节点最小 id 为 1，右侧节点最小 id 是 5。6>5,
  那按照二分法查找的规则，肯定就往右侧节点继续查找；
- 找到页号 30 的节点后，发现这个节点还有子节点（非叶子节点），那就继续比对，同理，6>5 && 6<7, 
  所以找到了页号 60；
- 找到页号 60 之后，发现此节点为叶子节点（数据节点），于是将此页数据加载至内存进行一一对比，
  结果找到了 id=6 的数据行。

从上述的过程中发现，我们为了查找 id=6 的数据，总共查询了三个页，如果三个页都在磁盘中（未提前加载至内存），
那么最多需要经历三次的磁盘 IO。

需要注意的是，图中的页号只是个示例，实际情况下并不是连续的，在磁盘中存储也不一定是顺序的。

至此，我们大概已经了解了表的数据是怎么个结构了，也大概知道查询数据是个怎么的过程了，
这样我们也就能大概估算这样的结构能存放多少数据了。

从上面的图解我们知道 B+ 数的叶子节点才是存在数据的，而非叶子节点是用来存放索引数据的。

所以，同样一个 16K 的页，非叶子节点里的每条数据都指向新的页，而新的页有两种可能

- 如果是叶子节点，那么里面就是一行行的数据
- 如果是[非叶子节点的话，那么就会继续指向新的页]

假设

- 非叶子节点内指向其他页的数量为 x
- 叶子节点内能容纳的数据行数为 y
- B+ 数的层数为 z

如下图中所示，**Total =x^(z-1) \*y 也就是说总数会等于 x 的 z-1 次方 与 Y 的乘积**。

![img.png](images/9.索引相关/二叉树的计算.png)

> X =？

在文章的开头已经介绍了页的结构，索引也也不例外，都会有 File Header (38 byte)、Page Header (56 Byte)、
Infimum + Supermum（26 byte）、File Trailer（8byte）, 再加上页目录，大概 1k 左右。

我们就当做它就是 1K, 那整个页的大小是 16K, 剩下 15k 用于存数据，在索引页中主要记录的是主键与页号，
主键我们假设是 Bigint (8 byte), 而页号也是固定的（4Byte）, 那么索引页中的一条数据也就是 12byte。

所以 x=15*1024/12≈1280 行。

> Y=？

叶子节点和非叶子节点的结构是一样的，同理，能放数据的空间也是 15k。

但是叶子节点中存放的是真正的行数据，这个影响的因素就会多很多，
比如，字段的类型，字段的数量。[每行数据占用空间越大，页中所放的行数量就会越少]。

这边我们暂时按一条行数据 1k 来算，那一页就能存下 15 条，Y = 15*1024/1000  ≈15。

算到这边了，是不是心里已经有谱了啊。

根据上述的公式，Total =x^(z-1) *y，已知 x=1280，y=15：

- 假设 B+ 树是两层，那就是 z = 2， Total = （1280 ^1 ）*15 = 19200
- 假设 B+ 树是三层，那就是 z = 3， Total = （1280 ^2） *15 = 24576000 （约 2.45kw）

哎呀，妈呀！这不是正好就是文章开头说的最大行数建议值 2000W 嘛！对的，一般[ B+ 数的层级最多也就是 3 层]。

你试想一下，如果是 4 层，除了查询的时候磁盘 IO 次数会增加，而且这个 Total 值会是多少，
大概应该是 3 百多亿吧，也不太合理，所以，3 层应该是比较合理的一个值。

> 到这里难道就完了？

不。

我们刚刚在说 Y 的值时候假设的是 1K ，那比如我实际当行的数据占用空间不是 1K , 而是 5K, 
那么单个数据页最多只能放下 3 条数据。

同样，还是按照 z = 3 的值来计算，那 Total = （1280 ^2） *3 = 4915200 （近 500w）

所以，在保持相同的层级（相似查询性能）的情况下，在[行数据大小不同的情况下，其实这个最大建议值也是不同的]，
而且影响查询性能的还有很多其他因素，比如，数据库版本，服务器配置，sql 的编写等等。

MySQL 为了提高性能，会将表的索引装载到内存中，在 InnoDB buffer size 足够的情况下，其能完成全加载进内存，
查询不会有问题。

但是，当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得[之后的 SQL 查询会产生磁盘 IO]，
从而导致性能下降，所以增加硬件配置（比如把内存当磁盘使），可能会带来立竿见影的性能提升哈。


# 索引原则
1. 对查询频次较高，数据量较大的表建立索引
2. 索引字段的选择，最佳候选列从WHERE中提取，挑选最常用的索引组合
3. 使用唯一索引，区分度越高，效率越高
4. 索引可以有效提升查询速度，但不是越多越好，越多
   1. 维护成本越高
   2. 也会有选择困难症，从多个索引中选择一个可用的，增加选择时间
5. 使用短索引，可以给定[大小存储块可以存储更多的索引值]，提升访问索引效率
6. 利用最左前缀，N个组合索引，可以利用组合索引提升效率
7. 对于[定义为text、image和bit]的数据类型的列不要建立索引


# 7. 索引失效有哪些？

![img.png](images/9.索引相关/索引失效总结.png)

## 总结

今天给大家介绍了 6 种会发生索引失效的情况：

- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列使用函数，就会导致索引失效。
- 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。
- MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

1. 全值匹配：对索引中所有值都执行具体值,3个键都有值
Select * from table where name=“小米科技” and status = 1 and address=”北京”
2. 最左前缀法则：查询从索引最左前列开始，并不跳转,

索引失效情况：跳过其中一条
Select * from table where status = ‘1’ and address=”北京”
Select * from table where  address=”北京”
索引不失效：和写的顺序无关，并未跳过
Select * from table where status = ‘1 and address=”北京” and name=”小米科技”
Select * from table where name=“小米科技”
Select * from table where name=“小米科技” and status = ‘1’
Select * from table where name=“小米科技” and address=”北京”

3. 范围查询右边的列，不能使用索引 >、<、between、like
Select * from table where address=”北京” and  status > 1 andname=”小米科技”
范围左边：address status 索引有效
范围右边 name 索引失效

4. 不要在索引上进行运算操作，索引失效
Select * from table where substrign(3,2) name=”科技”

5. 字符串不加单引号，索引失效 --隐式类型转换
Select * from table where name=”小米科技”and status =1 //status索引失效

6. 尽量使用覆盖索引，避免select *，查询列不是索引，会降低性能
7. or 会让索引失效


8. %开头的like模糊查询，索引失效，放在结尾可以

9. 如果mysql评估使用全表查询更快，索引失效

10. is null  is not null  有时失效，有时不失效。
取决与使用索引的速度是不是比全表快

11. in索引不失效， not in 索引失效
Select * from table where name in （ ”小米科技”，”JD”); //不失效
Select * from table where name NOT in （ ”小米科技”，”JD”);//失效

12. 单列索引和复合索引

使用索引查询一定能提高查询的性能吗？
不一定，不必要的索引反而会使查询反应时间变慢，因为索引需要空间来存储，也需要定期维护，
索引范围查询(INDEX RANGE SCAN)适用于两种情况:
基于一个范围的检索，一般查询返回结果集小于表中记录数的30%
基于非唯一性索引的检索

## 7.1 索引存储结构长什么样？

我们先来看看索引存储结构长什么样？因为只有知道索引的存储结构，才能更好的理解索引失效的问题。

索引的存储结构跟 MySQL 使用哪种存储引擎有关，因为存储引擎就是负责将数据持久化在磁盘中，
而不同的存储引擎采用的索引数据结构也会不相同。

MySQL 默认的存储引擎是 InnoDB，它采用 B+Tree 作为索引的数据结构，至于为什么选择B+ 树作为索引的数据结构 
详细的分析可以看我这篇文章：[为什么 MySQL 喜欢 B+ 树？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247502168&idx=1&sn=ff63afcea1e8835fca3fe7a97e6922b4&scene=21#wechat_redirect)

在创建表时，InnoDB 存储引擎默认会创建一个主键索引，也就是聚簇索引，其它索引都属于二级索引。

MySQL 的 MyISAM 存储引擎支持多种索引数据结构，比如 B+ 树索引、R 树索引、Full-Text 索引。
MyISAM 存储引擎在创建表时，创建的主键索引默认使用的是 B+ 树索引。

虽然，InnoDB 和 MyISAM 都支持 B+ 树索引，但是它们数据的存储结构实现方式不同。不同之处在于：

- InnoDB 存储引擎：B+ 树索引的【叶子节点保存数据本身】；
- MyISAM 存储引擎：B+ 树索引的[叶子节点保存数据的物理地址]；

接下来，我举个例子，给大家展示下这两种存储引擎的索引存储结构的区别。

这里有一张 t_user 表，其中 id 字段为主键索引，其他都是普通字段。

![img.png](images/9.索引相关/MyISAM%20B+树.png)

如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：

![img.png](images/9.索引相关/Innodedb%20B+树总结.png)

如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示：

![图片](https://img-blog.csdnimg.cn/img_convert/ef726d7287b854ea4862f7442d8012ec.png)

InnoDB 存储引擎根据索引类型不同，分为[聚簇索引（上图就是聚簇索引）和二级索引]。它们区别在于，
聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，
而二级索引的叶子节点存放的是主键值，而不是实际数据。

如果将 name 字段设置为普通索引，那么这个二级索引长下图这样，叶子节点仅存放主键值。

 ![img.png](images/9.索引相关/InnodeDb%20二级索引.png)

知道了 InnoDB 存储引擎的聚簇索引和二级索引的存储结构后，接下来举几个查询语句，
说下查询过程是怎么选择用哪个索引类型的。

在我们使用「主键索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在
「聚簇索引」中的 [B+ 树检索到对应的叶子节点，然后直接读取要查询的数据]。如下面这条语句：

```
// id 字段为主键索引
select * from t_user where id=1;
```

在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，
那么需要检索两颗B+树：

- 先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；
- 然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。

上面这个过程叫做**回表**，如下面这条语句：

```
// name 字段为二级索引
select * from t_user where name="林某";
```

在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，
那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做**覆盖索引**。
如下面这条语句：

```
// name 字段为二级索引
select id from t_user where name="林某";
```

上面这些查询语句的条件都用到了索引列，所以在查询过程都用上了索引。

但是并不意味着，查询条件用上了索引列，就查询过程就一定都用上索引，接下来我们再一起看看哪些情况会导致索引失效，
而发生全表扫描。

首先说明下，下面的实验案例，我使用的 MySQL 版本为 `8.0.26`。

## 7.2 对索引使用左或者左右模糊匹配

当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。

比如下面的 like 语句，查询 name 后缀为「林」的用户，执行计划中的 type=ALL 就代表了全表扫描，而没有走索引。

```
// name 字段为二级索引
select * from t_user where name like '%林';
```
![img.png](images/9.索引相关/索引失效1.png)

如果是查询 name 前缀为林的用户，那么就会走索引扫描，执行计划中的 type=range 表示走索引扫描，
key=index_name 看到实际走了 index_name 索引：

```
// name 字段为二级索引
select * from t_user where name like '林%';
```

![img.png](images/9.索引相关/索引失效2.png)

> 为什么 like 关键字左或者左右模糊匹配无法走索引呢？

**因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。**

举个例子，下面这张二级索引图，是以 name 字段有序排列存储的。

![img.png](images/9.索引相关/索引失效3.png)

假设我们要查询 name 字段前缀为「林」的数据，也就是 `name like '林%'`，扫描索引的过程：

- 首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，
   所以选择去节点2继续查询；
- 节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，
         发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；
- 节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，
     直到匹配不到前缀为林的索引值。

如果使用 `name like '%林'` 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。

想要更详细了解 InnoDB 的 B+ 树查询过程，可以看我写的这篇：[B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247502059&idx=1&sn=ccbee22bda8c3d6a98237be769a7c89c&scene=21#wechat_redirect)

## 7.3 对索引使用函数

有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，
就会导致[索引失效]。

比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type=ALL，代表了全表扫描：

```
// name 为二级索引
select * from t_user where length(name)=6;
```

![img.png](images/9.索引相关/索引失效4.png)

> 为什么对索引使用函数，就无法走索引了呢？

因为[索引保存的是索引字段的原始值]，而不是经过函数计算后的值，自然就没办法走索引了。

不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，
也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。

举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。

```
alter table t_user add key idx_name_length ((length(name)));
```

然后我再用下面这条查询语句，这时候就会走索引了。

![img.png](images/9.索引相关/索引失效5.png)

## 7.4 对索引进行表达式计算

在查询条件中对索引进行表达式计算，也是无法走索引的。

比如，下面这条查询语句，执行计划中 type = ALL，说明是通过全表扫描的方式查询数据的：

```
explain select * from t_user where id + 1 = 10;
```

![img.png](images/9.索引相关/索引失效6.png)

但是，如果把查询语句的条件改成 where id  = 10 - 1，这样就不是在索引字段进行表达式计算了，
于是就可以走索引查询了。

![img.png](images/9.索引相关/索引失效7.png)

> 为什么对索引进行表达式计算，就无法走索引了呢？

原因跟对索引使用函数差不多。

因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，
所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，
因此采用的就是全表扫描的方式。

有的同学可能会说，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，
比方将  id + 1 = 10 变成 id  = 10 - 1。

是的，是能够实现，但是 MySQL 还是偷了这个懒，没有实现。

我的想法是，可能也是因为，表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，
所以干脆将这种索引失效的场景告诉程序员，让程序员自己保证在查询条件中不要对索引进行表达式计算。

# 7.5 对索引隐式类型转换

如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。

我在原本的 t_user 表增加了 phone 字段，是二级索引且类型是 varchar。

![img.png](images/9.索引相关/索引失效8.png)

然后我在条件查询中，用整型作为输入参数，此时执行计划中 type = ALL，所以是通过全表扫描来查询数据的。

```
select * from t_user where phone = 1300000001;
```

![img.png](images/9.索引相关/索引失效9.png)

但是如果[索引字段是整型类型，查询条件中的输入参数即使字符串]，是不会导致索引失效，还是可以走索引扫描。

我们再看第二个例子，id 是整型，但是下面这条语句还是走了索引扫描的。

```
 explain select * from t_user where id = '1';
```

![img.png](images/9.索引相关/索引失效10.png)

> 为什么第一个例子会导致索引失效，而第二例子不会呢？

要明白这个原因，首先我们要知道 MySQL 的数据类型转换规则是什么？

就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。

我在看《mysql45讲的时候》看到一个简单的测试方式，就是通过 select “10” > 9 的结果来知道MySQL 的数据类型转换规则是什么：

- 如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 > 9，这个就是数字比较，所以结果应该是 1；
- 如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select "10" > "9"，这个是字符串比较，
  字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么"10"字符串相当于 “1”和“0”字符的组合，
  所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。

在 MySQL 中，执行的结果如下图：

![img.png](images/9.索引相关/索引失效11.png)

上面的结果为 1，说明 **MySQL 在[遇到字符串和数字比较的时候，会自动把字符串转为数字]，然后再进行比较**。

前面的例子一中的查询语句，我也跟大家说了是会走全表扫描：

```
//例子一的查询语句
select * from t_user where phone = 1300000001;
```

这是因为 phone 字段为字符串，所以 MySQL 要会[自动把字符串转为数字]，所以这条语句相当于：

```
select * from t_user where CAST(phone AS signed int) = 1300000001;
```

可以看到，**CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！
而前面我们也说了，对索引使用函数是会导致索引失效的**。

例子二中的查询语句，我跟大家说了是会走索引扫描：

```
//例子二的查询语句
select * from t_user where id = "1";
```

这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：

```
select * from t_user where id = CAST("1" AS signed int);
```

可以看到，索引字段并没有用任何函数，[CAST 函数是用在了输入参数，因此是可以走索引扫描的]。

## 7.6 联合索引非最左匹配

对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。

那么**多个普通字段组合在一起创建的索引就叫做联合索引**，也叫组合索引。

创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。

联合索引要能正确使用需要遵循**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。

比如，如果创建了一个 `(a, b, c)` 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：

- where a=1；
- where a=1 and b=2 and c=3；
- where a=1 and b=2；

需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。

但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:

- where b=2；
- where c=3；
- where b=2 and c=3；

有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？

这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。

MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行,然后再比对 c 字段的值。

从 MySQL 5.6 之后，有一个**索引下推功能**，可以在索引遍历过程中，对索引中包含的字段先做判断，
直接[过滤掉不满足条件的记录，减少回表次数]。

大概原理是：截断的字段会被下推到存储引擎层进行条件判断（因为 c 字段的值是在 `(a, b, c)` 联合索引里的），
然后过滤出符合条件的数据后再返回给 Server 层。由于在[引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断]，
减少回表次数，从而提升了性能。

比如下面这条 where a = 1 and c = 0 语句，我们可以从执行计划中的 Extra=Using index condition 
使用了索引下推功能。

![img.png](images/9.索引相关/索引失效12.png)

> 为什么联合索引不遵循最左匹配原则就会失效？

原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。

也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。
如果我们仅仅按照第二列搜索，肯定无法走索引。

## 7.7 WHERE 子句中的 OR

在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 [OR 后的条件列不是索引列，那么索引会失效]。

举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。

```
select * from t_user where id = 1 or age = 18;
```

![img.png](images/9.索引相关/索引失效13.png)

这是因为 OR 的含义就是两个只要满足一个即可，因此[只有一个条件列是索引列是没有意义的]，只要有条件列不是索引列，
就会进行全表扫描。

要解决办法很简单，将 age 字段设置为索引即可。

![img.png](images/9.索引相关/索引失效14.png)

可以看到 type=index merge， index merge 的意思就是[对 id 和 age 分别进行了扫描]，
然后将这两个结果集进行了合并，这样做的好处就是避免了全表扫描。

# 8. MySQL 使用 like “%x“，索引一定会失效吗？

昨天发了一篇关于索引失效的文章：[谁还没碰过索引失效呢](http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247503394&idx=1&sn=6e5b7b2c9bd9002a4b2dfa69273069b3&chksm=f98d8a88cefa039e726f1196ba14210ddbe49b5fcbb6da620778a7497fa25404433ef0b76268&scene=21#wechat_redirect)

我在文末留了一个有点意思的思考题：

![图片](https://img-blog.csdnimg.cn/img_convert/c3e14ca7c5581a84820f7a9d647d4d14.png)


这个思考题其实是出自于，我之前这篇文章「[一条 SQL 语句引发的思考](http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247495686&idx=2&sn=dfa18870d8cd2f430f893d402b9f4e54&chksm=f98db4accefa3dba680c1b343700ef87d184c45d4d7739bb0263cece3c1b21d0ca5f875736f6&scene=21#wechat_redirect)」中留言区一位读者朋友出的问题。

很多读者都在留言区说了自己的想法，也有不少读者私聊我答案到底是什么？

所以，我今晚就跟大家聊聊这个思考题。

##8.1 题目一

题目一很简单，相信大家都能分析出答案，我昨天分享的索引失效文章里也提及过。

**「题目 1 」**的数据库表如下，id 是主键索引，name 是二级索引，其他字段都是非索引字段。

![img.png](images/9.索引相关/题目1表.png)

这四条模糊匹配的查询语句，第一条和第二条都会走索引扫描，而且都是选择扫描二级索引（index_name），我贴个第二条查询语句的执行计划结果图：

![img.png](images/9.索引相关/题目1_1.png)

而第三和第四条会发生索引失效，执行计划的结果 type= ALL，代表了全表扫描。

![img.png](images/9.索引相关/题目1——2.png)


## 8.2 题目二

题目 2 的数据库表特别之处在于，只有两个字段，一个是主键索引 id，另外一个是二级索引 name。

![img.png](images/9.索引相关/题目2表.png)

针对题目 2 的数据表，第一条和第二条模糊查询语句也是一样可以走索引扫描，第二条查询语句的执行计划如下，Extra 里的 Using index 说明用上了覆盖索引：

![img.png](images/9.索引相关/题目2——1.png)

我们来看一下第三条查询语句的执行计划（第四条也是一样的结果）：

![img.png](images/9.索引相关/题目2——2.png)

从执行计划的结果中，可以看到 key=index_name，也就是说用上了二级索引，而且从 Extra 里的 Using index 说明用上了覆盖索引。

这是为什么呢？

首先，这张表的字段没有「非索引」字段，所以 `select *` 相当于 `select id,name`，然后**这个查询的数据都在二级索引的 B+ 树，
因为二级索引的 B+ 树的叶子节点包含「索引值+主键值」，所以查二级索引的 B+ 树就能查到全部结果了，这个就是[覆盖索引]。**

但是执行计划里的 type 是 `index`，这代表着是通过全扫描二级索引的 B+ 树的方式查询到数据的，也就是遍历了整颗索引树。

而第一和第二条查询语句的执行计划中 type 是 `range`，表示对索引列进行范围查询，也就是利用了索引树的有序性的特点，
通过查询比较的方式，快速定位到了数据行。

所以，type=range 的查询效率会比 type=index 的高一些。

> 为什么选择全扫描二级索引树，而不扫描聚簇索引树呢？

因为二级索引树的记录东西很少，就[只有「索引列+主键值」]，而聚簇索引记录的东西会更多，
比如聚簇索引中的叶子节点则记录了[主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列]。

再加上，这个 select * 不用执行回表操作。

所以， MySQL 优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多，
因此 MySQL 选择了[「全扫描二级索引树」]的方式查询数据。

> 为什么这个数据表加了非索引字段，执行同样的查询语句后，怎么变成走的是全表扫描呢？

加了其他字段后，`select * from t_user where name like "%xx";` 要查询的数据就不能只在二级索引树里找了，得需要回表操作才能完成查询的工作，再加上是左模糊匹配，无法利用索引树的有序性来快速定位数据，所以得在二级索引树逐一遍历，获取主键值后，再到聚簇索引树检索到对应的数据行，这样实在太累了。

所以，优化器认为上面这样的查询过程的成本实在太高了，所以直接选择全表扫描的方式来查询数据。

------

从这个思考题我们知道了，使用左模糊匹配（like "%xx"）并不一定会走全表扫描，关键还是看数据表中的字段。

如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。

再说一个相似，我们都知道联合索引要遵循最左匹配才能走索引，但是如果数据库表中的字段都是索引的话，即使查询过程中，
没有遵循最左匹配原则，也是走全扫描二级索引树(type=index)，比如下图：

![img.png](images/9.索引相关/全库扫描二级索引.png)


# 9. count(*) 和 count(1) 有什么区别？哪个性能最好？

当我们对一张数据表中的记录进行统计的时候，习惯都会使用 count 函数来统计，
但是 count 函数传入的参数有很多种，比如 count(1)、count(`*`)、count(字段) 等。

到底哪种效率是最好的呢？是不是 count(`*`) 效率最差？

我曾经以为 count(`*`) 是效率最差的，因为认知上 `selete * from t` 会读取所有表中的字段，
所以凡事带有 `*` 字符的就觉得会读取表中所有的字段，当时网上有很多博客也这么说。

但是，当我深入 count 函数的原理后，被啪啪啪的打脸了！

不多说， 发车！

![img.png](images/9.索引相关/count%20总结.png)

## 9.1 哪种 count 性能最好？

我先直接说结论：

![img.png](images/9.索引相关/count%20结论.png)

要弄明白这个，我们得要深入 count 的原理，以下内容基于常用的 innodb 存储引擎来说明。

### 9.1.1 count() 是什么？

count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，
该函数作用是**[统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个]**。

假设 count() 函数的参数是字段名，如下：

```sql
select count(name) from t_order;
```

这条语句是统计「 t_order 表中，name 字段不为 NULL 的记录」有多少个。
也就是说，如果某一条记录中的 name 字段的值为 NULL，则就不会被统计进去。

再来假设 count() 函数的参数是数字 1 这个表达式，如下：

```sql
select count(1) from t_order;
```

这条语句是统计「 t_order 表中，1 这个表达式不为 NULL 的记录」有多少个。

1 这个表达式就是单纯数字，它永远都不是 NULL，所以上面这条语句，其实[是在统计 t_order 表中有多少个记录]。

### 9.1.2 count(主键字段) 执行过程是怎样的？

在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。

server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，
那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。

InnoDB 是通过 B+ 树来保存记录的，根据索引的类型又分为聚簇索引和二级索引，它们区别在于，
聚簇索引的叶子节点存放的是实际数据，而二级索引的叶子节点存放的是主键值，而不是实际数据。

用下面这条语句作为例子：

```sql
//id 为主键值
select count(id) from t_order;
```

如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，
然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。

![img.png](images/9.索引相关/count主键1.png)

但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。

![img.png](images/9.索引相关/count主键2.png)

这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。

### 9.1.3 count(1) 执行过程是怎样的？

用下面这条语句作为例子：

```
select count(1) from t_order;
```

如果表里只有主键索引，没有二级索引时。

![img.png](images/9.索引相关/count(1)_1.png)

那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，**但是不会读取记录中的任何字段的值**，
因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，
因此 server 层每从 [InnoDB 读取到一条记录，就将 count 变量加 1]。

可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是[不需要读取记录中的字段值]，所以通常会说 
count(1) 执行效率会比 count(主键字段) 高一点。

但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。

![img.png](images/9.索引相关/count(1)_2.png)

### 9.1.4 count(*) 执行过程是怎样的？

看到 `*` 这个字符的时候，是不是大家觉得是读取记录中的所有字段值？

对于 `selete *` 这条语句来说是这个意思，但是在 count(*)  中并不是这个意思。

**count(`\*`) 其实等于 count(`0`)**，也就是说，当你使用 count(`*`)  时，
MySQL 会将 `*` 参数转化为参数 0 来处理。

![img.png](images/9.索引相关/count(*).png)

所以，**count(\*) 执行过程跟 count(1) 执行过程基本一样的**，性能没有什么差异。

在 MySQL 5.7 的官方手册中有这么一句话：

*InnoDB handles SELECT COUNT(`\*`) and SELECT COUNT(`1`) operations in the same way. 
There is no performance difference.*

*翻译：InnoDB以相同的方式处理SELECT COUNT（`\*`）和SELECT COUNT（`1`）操作，没有性能差异。*

而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，
优化器会使用[key_len 最小的二级索引进行扫描]。

只有当没有二级索引的时候，才会采用主键索引来进行统计。

### 9.1.5 count(字段) 执行过程是怎样的？

count(字段) 的执行效率相比前面的 count(1)、 count(*)、 count(主键字段) 执行效率是最差的。

用下面这条语句作为例子：

```sql
-- name不是索引，普通字段
select count(name) from t_order;
```

对于这个查询来说，会采用全表扫描的方式来计数，所以它的执行效率是比较差的。

![img.png](images/9.索引相关/count(name).png)

### 9.1.7 小结

count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。

所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，
这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。

再来，就是[不要使用 count(字段)  来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计]。
如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。

## 9.2 为什么要通过遍历的方式来计数？

你可能会好奇，为什么 count 函数需要通过遍历的方式来统计记录个数？

我前面将的案例都是基于 Innodb 存储引擎来说明的，但是在 MyISAM 存储引擎里，执行 count 函数的方式是不一样的，
通常在没有任何查询条件下的 count(*)，MyISAM 的查询速度要明显快于 InnoDB。

使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 
[meta 信息有存储了row_count值，由表级锁保证一致性，所以直接读取 row_count ] 值就是 count 函数的执行结果。

而 InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，
InnoDB 表“应该返回多少行”也是不确定的，所以无法像 MyISAM一样，只维护一个 row_count 变量。

举个例子，假设表 t_order 有 100 条记录，现在有两个会话并行以下语句：

![img_1.png](images/9.索引相关/并发.png)

在会话 A 和会话 B的最后一个时刻，同时查表 t_order 的记录总个数，可以发现，显示的结果是不一样的。
所以，在使用 InnoDB 存储引擎时，就需要扫描表来统计具体的记录。

而当带上 where 条件语句之后，MyISAM 跟 InnoDB 就没有区别了，它们都需要扫描表来进行记录个数的统计。

## 9.3 如何优化  count(*)？

如果对一张大表经常用 count(*) 来做统计，其实是很不好的。

比如下面我这个案例，表 t_order 共有 1200+ 万条记录，我也创建了二级索引，但是执行一次 `select count(*) from t_order` 
要花费差不多 5 秒！

![img.png](images/9.索引相关/count(*)优化1.png)

面对大表的记录统计，我们有没有什么其他更好的办法呢？

### 9.3.1 第一种，近似值

如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值。

![img.png](images/9.索引相关/count(*)优化2.png)

这时，我们就可以使用 show table status 或者 explain 命令来表进行估算。

执行 explain 命令效率是很高的，因为它并不会真正的去查询，下图中的 rows 字段值就是  
explain 命令对表 t_order 记录的估算值。

![img.png](images/9.索引相关/count(*)优化3.png)

### 第二种，额外表保存计数值

如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。

当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，
我们需要[额外维护这个计数表]。


# 索引语法
索引创建：
1.创建表的同时创建
```sql
CREATE TABLE user_index2 (
id INT auto_increment PRIMARY KEY,
first_name VARCHAR (16),
last_name VARCHAR (16),
id_card VARCHAR (18),
information text,
KEY name (first_name, last_name),
FULLTEXT KEY (information),
UNIQUE KEY (id_card)
);
```

2. 表创建完成后添加
```sql
CREATE [UNIQUE|FULLTXT|SPARTIAL] INDEX index_name
[USING index_type ] ON table_name(col_name)
-- 示例：CREATE INDEX idx_city_name ON city(city_name);

```

3. 使用ALTER TABLE命令去增加索引
ALERT 命令：
```sql
Alter table table_name add primay key(col_name):添加主键索引值唯一不NULL
Alter table table_name add unique index_name(col_name):索引唯一，可多NULL
Alter table table_name add index index_name (col_name)普通索引，索引可重复
Alter table table_name add fulltex index_name (col_name)用于全文索引
```

索引创建注意事项：
1. [非空字段]：指定列NOT NULL，除非你想存储NULL。用0或特殊符替换
在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。
2. [索引字段越小越好]：数据库的数据存储以页为单位一页存储的数据越多一		次IO操作获取的数据越大效率越高
3. [取值离散大]的字段：离散大的列放到联合索引的前面，
可用count()查看字段差异值，值越大说明字段离散程度高，唯一值越多

索引查看：

```Show index from table_name;```
PRIMARY:主键索引

# 查索引使用情况
命令：```show （global）status like “Handle_read%”```
- Handler_read_first:索引中第一条被读的次数，如果高表示大量全索引扫描
- Handler_read_key:索引被读的次数，越多说明该key越有效
- Handler_read_next:按key顺序读取下一行请求，范围约束或索引扫描
- Handler_read_prev:按key顺序读前一行，用于优化ORDER BY..DESC
- Handler_read_rnd:该值高，说明大量查询使用，需要添加键增加效率
- Handler_read_rnd_next:该值高，说明索引不正确或没有利用索引
