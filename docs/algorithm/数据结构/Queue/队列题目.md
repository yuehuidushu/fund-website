---
sidebar_position: 0
tags:
- 队列
- 队列题目
---
# 队列题目

## 1. 用两个栈实现队列
```java
public class _232_MyQueueWithStack<E> {
	private Stack<E> in;
	private Stack<E> out;
	
    /** Initialize your data structure here. */
    public _232_MyQueueWithStack() {
    	in = new Stack<>();
    	out = new Stack<>();
    }
    
    /** Push element x to the back of queue. */
    public void push(E x) {
    	in.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public E pop() {
    	checkOutstack();
    	return out.pop();
    }
    
    /** Get the front element. */
    public E peek() {
    	checkOutstack();
    	return out.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
    	return in.isEmpty() && out.isEmpty();
    }
    
    private void checkOutstack() {
		if(out.isEmpty()) {
			while(!in.isEmpty())
				out.push(in.pop());
		}
	}
}

```

## 2.最大的滑动窗口--重新做
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

```java
/**
	输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
	输出: [3,3,5,5,6,7] 
	解释: 

  滑动窗口的位置                最大值
	---------------               -----
	[1  3  -1] -3  5  3  6  7      3
 	1 [3  -1  -3] 5  3  6  7       3
 	1  3 [-1  -3  5] 3  6  7       5
 	1  3  -1 [-3  5  3] 6  7       5
 	1  3  -1  -3 [5  3  6] 7       6
 	1  3  -1  -3  5 [3  6  7]      7

*/
public class _239_maxSlidingWindow {
	public static int[] maxSlidingWindow(int[] nums, int k) {
		if(null == nums || k <= 0 || 0 == nums.length) return null;
		
		int len = nums.length;
		int[] result = new int[len - k + 1];
		LinkedList<Integer> list = new LinkedList<>();
		int maxIdex = -1;
		
		for(int i = 0; i < len; i++) {
			if(list.isEmpty() || i < k -1) {
				list.add(nums[i]);
				break;
			}
			while(!list.isEmpty()) {
				if(nums[i] > list.peek())
					list.poll();
				else {
					
				}
			}
		}
		return result;
	}
	
	public static int[] maxSlidingWindow1(int[] nums, int k) {
		if(null == nums || k <= 0 || 0 == nums.length) return null;

        int[] result = new int[nums.length - k + 1];
        int maxIndex = -1;
        int j = 0;
        for(int i = 0; i <= nums.length - k; i++){
            if(i <= maxIndex && maxIndex < i + k){
                if(nums[maxIndex] <= nums[i+k-1]){
                    maxIndex = i+k-1;
                }
            } else {
                maxIndex = i;
                for(int m = i; m <= i + k -1; m++){
                    if(nums[maxIndex] < nums[m]) maxIndex = m;
                }
            }
            result[j++] = nums[maxIndex];
        }
        return result;
	}
}
```


